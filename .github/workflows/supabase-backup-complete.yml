name: supabase-backup-complete

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  backup:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Complete backup (schema + data)
        run: |
          mkdir -p supabase-backups

          # Script de backup complet
          cat > complete_backup.js << 'EOF'
          const fs = require('fs');

          const SUPABASE_URL = "https://mkbchdhbgdynxwfhpxbw.supabase.co";
          const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

          async function getSchema() {
            // RÃ©cupÃ©rer la structure des tables
            const schemaQuery = `
              SELECT
                table_name,
                column_name,
                data_type,
                is_nullable,
                column_default
              FROM information_schema.columns
              WHERE table_schema = 'public'
              ORDER BY table_name, ordinal_position
            `;

            const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/execute_sql`, {
              method: 'POST',
              headers: {
                'apikey': SUPABASE_KEY,
                'Authorization': `Bearer ${SUPABASE_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ query: schemaQuery })
            });

            if (response.ok) {
              return await response.json();
            }
            return null;
          }

          async function getAllTables() {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_table_list`, {
              method: 'POST',
              headers: {
                'apikey': SUPABASE_KEY,
                'Authorization': `Bearer ${SUPABASE_KEY}`,
                'Content-Type': 'application/json'
              }
            });

            if (response.ok) {
              const result = await response.json();
              return result.map(t => t.table_name);
            }

            // Fallback: liste des tables connues
            return [
              'users', 'lieux', 'planning_hebdomadaire', 'planning_formateurs_hebdo',
              'planning_apprenants', 'presence_formateurs', 'absences_formateurs',
              'absences_apprenants', 'messages', 'quiz', 'quiz_categories',
              'quiz_sessions', 'admin_sessions', 'suspensions_parcours',
              'imagiers', 'imagier_elements', 'mots_extraits', 'mots_classifies',
              'corrections_demandees', 'corrections_mono_multi', 'corrections_syllabification',
              'signalements_syllabification', 'syllabes', 'syllabes_mots',
              'paniers_syllabes', 'groupes_sens', 'textes_references', 'planning_type_formateurs'
            ];
          }

          async function completeBackup() {
            console.log('ðŸ”„ DÃ©but du backup complet...');

            const tables = await getAllTables();
            const backup = {
              timestamp: new Date().toISOString(),
              tables: {},
              schema: null
            };

            // RÃ©cupÃ©rer le schÃ©ma
            backup.schema = await getSchema();

            // RÃ©cupÃ©rer les donnÃ©es de chaque table
            for (const table of tables) {
              try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${table}?select=*`, {
                  headers: {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`,
                    'Accept': 'application/json'
                  }
                });

                if (response.ok) {
                  const data = await response.json();
                  backup.tables[table] = data;
                  console.log(`âœ… ${table}: ${data.length} enregistrements`);
                } else {
                  console.log(`âŒ ${table}: Erreur ${response.status}`);
                }
              } catch (error) {
                console.log(`âŒ ${table}: ${error.message}`);
              }
            }

            // Sauvegarder le backup complet
            fs.writeFileSync('supabase-backups/complete_backup.json', JSON.stringify(backup, null, 2));

            // GÃ©nÃ©rer le script SQL de restauration
            let restoreSQL = '-- Script de restauration complÃ¨te\n\n';

            // TODO: GÃ©nÃ©rer CREATE TABLE depuis le schÃ©ma
            if (backup.schema) {
              restoreSQL += '-- SchÃ©ma des tables\n';
              // Ici on pourrait gÃ©nÃ©rer les CREATE TABLE
            }

            // GÃ©nÃ©rer les INSERT
            for (const [tableName, data] of Object.entries(backup.tables)) {
              if (data && data.length > 0) {
                restoreSQL += `\n-- Table: ${tableName}\n`;
                restoreSQL += `TRUNCATE TABLE IF EXISTS "${tableName}" RESTART IDENTITY CASCADE;\n`;

                for (const row of data) {
                  const columns = Object.keys(row).map(col => `"${col}"`).join(', ');
                  const values = Object.values(row).map(val => {
                    if (val === null) return 'NULL';
                    if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
                    if (typeof val === 'object') return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
                    return val;
                  }).join(', ');
                  restoreSQL += `INSERT INTO "${tableName}" (${columns}) VALUES (${values});\n`;
                }
              }
            }

            fs.writeFileSync('supabase-backups/restore_complete.sql', restoreSQL);

            console.log('ðŸŽ‰ Backup complet terminÃ© !');
            console.log(`ðŸ“Š ${Object.keys(backup.tables).length} tables sauvegardÃ©es`);
          }

          completeBackup().catch(console.error);
          EOF

          node complete_backup.js

        env:
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

      - name: Commit backup files
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'Backup Supabase complet - $(date)'
          file_pattern: 'supabase-backups/*'